### ---------------------------------------------------------------- ###
### functions for mass spectrometry:
###  1. (mass ID)
###  2. load PTR-TOF spectra
###  3. normalize and average PTR-TOF spectra
###  4. rotate spectra and make timeseries plots
###  5. load CIMS data
###  6. load CIMS spectra
###  7. run CIMS diagnostics
###  8. process CIMS data
###  9. normalize CIMS data
###
### version 3.4, Feb 2016
### author: RS
### ---------------------------------------------------------------- ###

fLoadTOF <- function(spect.dir, spect.name) {
  ## 2. load spectra file generated by PTR-TOF instrument
  ##
  ## PTR-TOF spectra files are in CSV format:
  ##   scan n.     m/z         m/z         m/z
  ##     0          1           2           3
  ##     1       ion count   ion count   ion count
  ##     2       ion count   ion count   ion count
  ##
  ## input:
  ##     spect.dir = PTR-TOF spectra file directory
  ##     spect.name = name of PTR-TOF spectra file
  ## output:
  ##     spect.out = data.frame ( mz, scan1, scan2, scan3, ... )
  ## ------------------------------------------------------------
  ## load spectra file
  spect.file <- paste(spect.dir, spect.name, sep="")
  spect.data <- read.delim(spect.file, header=FALSE, sep=",")
  ## spectra header (first row)
  n.scan <- nrow(spect.data) - 1
  spect.ions <- paste("scan", seq(1, n.scan, by=1), sep="")
  spect.head <- c("mz", spect.ions)
  ## spectra data (drop first and last columns)
  n.ion <- ncol(spect.data) - 1
  spect.matx <- t(spect.data[,2:n.ion])
  ## output data.frame
  spect.out <- data.frame(spect.matx)
  rownames(spect.out) <- NULL
  colnames(spect.out) <- spect.head
  return(spect.out)
}

fNormTOF <- function(spect.df, ref.mz, scan.ini, scan.fin) {
  ## 3. normalize PTR-TOF spectra to 1 million counts of a reference
  ## ion (e.g., [H3O]+); calculate average spectrum and standard
  ## deviation of a group of normalized scans
  ##
  ## NB: see documentation of fLoadTOF()
  ##
  ## input:
  ##     spect.df = data.frame of spectra (m/z, scan1, scan2, ...)
  ##     ref.mz = mass of reference ion
  ##     scan.ini = n. initial scans to exclude from average
  ##     scan.fin = n. final scans to exclude from average
  ## output:
  ##     spect.out = data.frame ( mz, scan1, scan2, ...,
  ##                              scan.avg, scan.std )
  ## ------------------------------------------------------------
  if (!is.data.frame(spect.df)) {
    df.name <- deparse(substitute(spect.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## reference ion count
  ref.r <- which(spect.df["mz"] == as.numeric(ref.mz))
  ref.ic <- as.numeric(spect.df[ref.r,])
  ## normalize spectra
  spect.norm <- t(apply(spect.df, 1, function(x)
                        x * 1e6 / ref.ic))
  spect.norm[,1] <- spect.df[,1]
  nsp <- ncol(spect.norm)
  ## calculate average spectrum and standard deviation
  smin <- as.numeric(scan.ini) + 2
  smax <- nsp - as.numeric(scan.fin)
  spect.avg <- apply(spect.norm[,smin:smax], 1, mean)
  spect.std <- apply(spect.norm[,smin:smax], 1, sd)
  ## output data.frame
  spect.out <- as.data.frame(spect.norm) #!
  spect.out[,(nsp+1)] <- spect.avg
  spect.out[,(nsp+2)] <- spect.std
  colnames(spect.out)[(nsp+1)] <- "scan.avg"
  colnames(spect.out)[(nsp+2)] <- "scan.std"
  return(spect.out)
}

fPlotSpect <- function(spect.df, mz.min, mz.max, sc.min, sc.max, fn.str) {
  ## 4. rotate data.frame of spectra; make plots of time spectra
  ## (ion counts vs. number of scans) for a given interval of masses
  ## and save plots to pdf file
  ##
  ## input:
  ##     spect.df = data.frame ( mass, scan1, scan2, scan3, ... )
  ##     mz.min = smallest mass to plot
  ##     mz.max = largest mass to plot
  ##     sc.min = smallest mass to plot
  ##     sc.max = largest mass to plot
  ##     fn.str = name of file to save plot OR ""
  ## output:
  ##     spect.out = data.frame ( n. scan, mass1, mass2, mass3, ... )
  ##     --> plot of time spectra
  ##     --> png file : `fn.str'.png
  ## ------------------------------------------------------------
  if (!is.data.frame(spect.df)) {
    df.name <- deparse(substitute(spect.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## rotate data.frame and add vector with scan number
  mz.vec <- spect.df[,1]
  spect.t <- t(spect.df[,-1])
  rownames(spect.t) <- NULL
  colnames(spect.t) <- paste("m", mz.vec, sep="")
  n.scan <- seq(1, nrow(spect.t), by=1)
  ## select range of masses
  mz.inter <- which((mz.vec > mz.min) & (mz.vec < mz.max))
  ## plot time spectra in 4x4 panels
  par(mfrow = c(4,4))
  for (i in mz.inter) {
      spect.ic <- spect.t[,i]
      if (all(is.na(spect.ic)) == FALSE) {  # time spectrum #!
          plot(n.scan, spect.ic, type="o", cex=0.6,
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      } else {                              # empty plot
          plot(0, 0, type="o", cex=0.6,
               xlim=c(-1,1), ylim=c(-1,1),
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      }
  }
  if (fn.str != "") {
    dev.copy(png, paste(fn.str, ".png", sep=""),
             width=297, height=210, units="mm", res=150)
    dev.off()
  }
  ## output data.frame
  spect.out <- as.data.frame(cbind(n.scan, spect.t)) #!
  return(spect.out)
}

fLoadCIMS <- function(cims.dir, cims.fn) {
  ## 5. load data file generated by CIMS instrument
  ##
  ## input:
  ##     cims.dir = CIMS data file directory
  ##     cims.fn = name of CIMS data file
  ## output:
  ##     cims.out = data.frame ( time variables, data variables,
  ##                             diagnostic variables )
  ## ------------------------------------------------------------
  ## load CIMS data file (drop last row)
  cims.file <- paste(cims.dir, cims.fn, sep="")
  cims.df <- read.delim(cims.file, header=TRUE, sep="")
  cims.df <- cims.df[-nrow(cims.df),]
  ## separate variables into groups
  nvar <- length(colnames(cims.df))
  cims1 <- cims.df[,1:8]             # time
  cims2 <- cims.df[,9:11]            # n. cycles, mass channels, analog signals
  cims3 <- cims.df[,12:15]           # cycles
  cims4 <- cims.df[,16:(nvar-32)]    # Hz, mass, dwell time
  cims5 <- cims.df[,(nvar-31):nvar]  # analog signals
  ## convert date/time strings to chron
  tst.d <- paste(cims1$yr, cims1$mo, cims1$dm, sep="-")
  tst.t <- paste(cims1$hr, cims1$mn, cims1$sc, sep=":")
  tst.dt <- paste(tst.d, tst.t, sep=" ")
  cims.d <- fChronStr(tst.d, "y-m-d")
  cims.t <- fChronStr(tst.t, "h:m:s")
  cims.dt <- fChronStr(tst.dt, "y-m-d h:m:s")
  cims.time <- data.frame(cims.dt, cims.d, cims.t)
  rownames(cims.time) <- NULL
  colnames(cims.time) <- c("Datetime", "Date", "Time")
  ## output data.frame
  cat("loaded:", cims.fn)
  cat(" [", as.character(cims2$nh[1]), "mass channels ]\n")
  cims.out <- data.frame(cims.time, cims4, cims2, cims3, cims5)
  return(cims.out)
}

fSpectraCIMS <- function(cims.dir, cims.lst) {
  ## 6. load spectra files generated by CIMS instrument
  ##
  ## NB: see documentation of fLoadCIMS()
  ##
  ## input:
  ##     cims.dir = CIMS spectra files directory
  ##     cims.lst = list of CIMS spectra filenames
  ## output:
  ##     spect.out = list ( data.frame ( start chron, stop chron ),
  ##                        data.frame ( amu, ic_mmdd_hhmm, ... ) )
  ## ------------------------------------------------------------
  if (!is.list(cims.lst)) {
    lst.name <- deparse(substitute(cims.lst))
    stop(paste(lst.name, "must be a list", sep=" "))
  }
  ## initialize lists and chron vectors
  spectra.list <- list()
  spectra.name <- list()
  spectra.start <- chron(format=c(dates="d-m-y", times="h:m:s"))
  spectra.stop <- chron(format=c(dates="d-m-y", times="h:m:s"))
  ## load spectra files
  for (i in 1:length(cims.lst)) {
    cims.fn <- cims.lst[[i]]
    cat("loading:", cims.fn, "\n")
    spect.data <- fLoadCIMS(cims.dir, cims.fn)
    ## extract mass and ion counts and add to list
    spect.ic <- data.frame(amu = (spect.data[,5] / 1000),
                           ic = (spect.data[,4] * (spect.data[,6] / 1000)))
    spectra.list[[i]] <- spect.ic
    ## get spectrum name ('_mmdd_hhmm') and add to list
    spect.str <- gsub("-", "", substr(cims.fn, 13, 23))
    spectra.name[[i]] <- paste("_", spect.str, sep="")
    ## get spectrum start/stop datetime
    spect.dt <- spect.data$Datetime
    spectra.start[i] <- spect.dt[1]
    spectra.stop[i] <- spect.dt[length(spect.dt)]
  }
  ## spectra start/stop timestamp
  spectra.tst <- data.frame(StartTime = spectra.start,
                            StopTime = spectra.stop)
  ## merged spectra data.frame
  if (length(spectra.name) == 1) {
    spectra.df <- spectra.list[[1]]
    colnames(spectra.df) <- c("amu", paste("ic", spectra.name[[1]], sep=""))
  } else {
    spectra.df <- fMergeDF(spectra.list, "amu", "TRUE", spectra.name)
  }
  ## output list
  spect.out <- list(spectra.tst, spectra.df)
  return(spect.out)
}

fDiagnCIMS <- function(cims.df, fn.str) {
  ## 7. run basic diagnostics on CIMS data and make plot of diagnostic
  ## variables
  ##
  ## NB: see documentation of fLoadCIMS()
  ##
  ## input:
  ##     cims.df = data.frame of CIMS data
  ##     fn.str = name of file to save plot OR ""
  ## output:
  ##     --> plot of diagnostic variables
  ##     --> png file : `fn.str'.png
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## set diagnostic variables
  t.stamp <- cims.df$Datetime  # timestamp
  n.cyc <- cims.df$nc          # n. cycles
  n.hop <- cims.df$nh          # n. mass channels
  n.ans <- cims.df$na          # n. analog signals
  cyc.0 <- cims.df$cB          # flag x cycle B (background)
  cyc.1 <- cims.df$cC          # flag x cycle C (background)
  cyc.2 <- cims.df$c2          # flag x cycle 2
  cyc.3 <- cims.df$c3          # flag x cycle 3
  fptv.a01 <- cims.df$A01      # MFC 1
  fptv.a02 <- cims.df$A02      # MFC 2 (CH3I flow)
  fptv.a05 <- cims.df$A05      # Vaisala RH
  fptv.a06 <- cims.df$A06      # Vaisala Temp
  fptv.a07 <- cims.df$A07      # MFC 7 (N2 flow)
  fptv.a08 <- cims.df$A08      # FT pressure
  hv.a01 <- cims.df$A17        # pinhole
  hv.a06 <- cims.df$A22        # octopole plate
  hv.a07 <- cims.df$A23        # CDC DC
  hv.a08 <- cims.df$A24        # CDC RF
  hv.a09 <- cims.df$A25        # octopole RF
  hv.a10 <- cims.df$A26        # octopole DC
  hv.b05 <- cims.df$A30        # CDC pressure
  hv.b06 <- cims.df$A31        # Main pressure
  hv.b07 <- cims.df$A32        # Quad pressure
  ## check consistency of parameters and flags
  if (length(unique(n.cyc)) != 1) {
    cat("CONFLICT! n. cycles:", unique(n.cyc), "\n")
  }
  if (length(unique(n.hop)) != 1) {
    cat("CONFLICT! n. mass channels:", unique(n.hop), "\n")
  }
  if (length(unique(n.ans)) != 1) {
    cat("CONFLICT! n. analog signals:", unique(n.ans), "\n")
  }
  if (length(unique(cyc.0)) != 1 && length(unique(cyc.0)) != 2) {
    cat("CONFLICT! flag x cycle B:", unique(cyc.0), "\n")
  }
  if (length(unique(cyc.1)) != 1 && length(unique(cyc.1)) != 2) {
    cat("CONFLICT! flag x cycle C:", unique(cyc.1), "\n")
  }
  if (length(unique(cyc.2)) != 1) {
    cat("CONFLICT! flag x cycle 2:", unique(cyc.2), "\n")
  }
  if (length(unique(cyc.3)) != 1) {
    cat("CONFLICT! flag x cycle 3:", unique(cyc.3), "\n")
  }
  if (identical(cyc.0, cyc.1) != TRUE) {
    cat("CONFLICT! flags x background cycles:", unique(cyc.0), "\n")
  }
  ## make plot of diagnostic variables with reference values
  par(mfrow = c(3,4), bg="white")
  plot(t.stamp, fptv.a02, type="l", ylim=c(400,600),
       xlab="time", ylab="mV", main="MeI flow")
  lines(t.stamp, rep(500, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, fptv.a07, type="l", ylim=c(1900,2100),
       xlab="time", ylab="mV", main="N2 flow")
  lines(t.stamp, rep(2000, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a01, type="l", ylim=c(-300,-180),
       xlab="time", ylab="mV", main="pinhole")
  lines(t.stamp, rep(-250, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a06, type="l", ylim=c(0,150),
       xlab="time", ylab="mV", main="octopole plate")
  lines(t.stamp, rep(67, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a07, type="l", ylim=c(-100,50),
       xlab="time", ylab="mV", main="CDC DC")
  lines(t.stamp, rep(-46, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a08, type="l", ylim=c(1700,1900),
       xlab="time", ylab="mV", main="CDC RF")
  lines(t.stamp, rep(1850, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a09, type="l", ylim=c(1000,3000),
       xlab="time", ylab="mV", main="octopole RF")
  lines(t.stamp, rep(1900, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a10, type="l", ylim=c(400,800),
       xlab="time", ylab="mV", main="octopole DC")
  lines(t.stamp, rep(496, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, fptv.a08, type="l", ylim=c(700,1400),
       xlab="time", ylab="mV", main="FT pressure")
  grid()
  plot(t.stamp, hv.b05, type="l", ylim=c(5500,5900),
       xlab="time", ylab="mV", main="CDC pressure")
  grid()
  plot(t.stamp, hv.b06, type="l", ylim=c(3500,3900),
       xlab="time", ylab="mV", main="Main pressure")
  grid()
  plot(t.stamp, hv.b07, type="l", ylim=c(1800,2100),
       xlab="time", ylab="mV", main="Quad pressure")
  grid()
  ## save plot of diagnostic variables
  if (fn.str != "") {
    dev.copy(png, paste(fn.str, ".png", sep=""),
             width=297, height=210, units="mm", res=150)
    dev.off()
  }
}

fProcessCIMS <- function(cims.df, bkgd.set) {
  ## 8. process CIMS data: separate data and diagnostic variables,
  ## check monitored masses and dwell times, calculate temperature and
  ## relative humidity from Vaisala probe, flag instrument background
  ## (if background box ON)
  ##
  ## NB: see documentation of fLoadCIMS()
  ##
  ## input:
  ##     cims.df = data.frame of CIMS data
  ##     bkgd.set = background box setting ("on" OR "off")
  ## output:
  ##     cims.out = data.frame ( time variables, processed data,
  ##                             diagnostic variables, relative humidity,
  ##                             temperature, background flag )
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## separate CIMS variables
  var.str <- colnames(cims.df)
  cims.time <- cims.df[,c("Datetime", "Date", "Time")]
  cims.data <- cbind(cims.df[,grep("^Hz", var.str)],
                     cims.df[,grep("^mamu", var.str)],
                     cims.df[,grep("^ms", var.str)])
  cims.diagn <- cbind(cims.df[,grep("^n", var.str)],
                      cims.df[,grep("^c", var.str)],
                      cims.df[,grep("^A", var.str)])
  ## ion count per second, atomic mass (amu), dwell time (s)
  n.mz <- length(colnames(cims.data)) / 3
  ic.hz <- cims.data[,1:n.mz]
  ic.am <- cims.data[,(n.mz+1):(2*n.mz)]
  ic.ms <- cims.data[,(2*n.mz+1):(3*n.mz)]
  cims.ic <- ic.hz
  cims.amu <- ic.am / 1000
  cims.sec <- ic.ms / 1000
  colnames(cims.ic) <- gsub("Hz", "m", colnames(cims.ic))
  colnames(cims.amu) <- gsub("mamu", "amu", colnames(cims.amu))
  colnames(cims.sec) <- gsub("ms", "sec", colnames(cims.sec))
  ## check consistency of monitored masses and dwell times
  print(colMeans(cims.amu, na.rm=TRUE))
  print(colMeans(cims.sec, na.rm=TRUE))
  ## temperature and relative humidity (Vaisala probe)
  probe.rh <- (cims.diagn$A05 / 1000) * 20
  probe.temp <- (cims.diagn$A06 / 1000) * 30 - 70
  cims.probe <- data.frame(Vaias.RH = probe.rh, Vaias.T = probe.temp)
  ## create instrument background flag:
  ##   0 = signal
  ##  -1 = before/after valve switch
  ##   1 = background
  cims.flag <- rep(0, nrow(cims.time))
  if (bkgd.set == "on") {
    fl1 <- cims.diagn$cB
    fl2 <- cims.diagn$cB
    fl1[which(cims.diagn$cB == 1) - 10] <- 2
    fl2[which(cims.diagn$cB == 1) + 10] <- 2
    cims.flag <- ifelse((fl1 == fl2 & fl1 == 2), 1,
                        ifelse((fl1 == fl2 & fl1 == 0), 0, -1))
  }
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.amu, cims.ic, cims.sec,
                         cims.diagn, cims.probe,
                         Flag_Bgd = cims.flag)
  return(cims.out)
}

fNormCIMS <- function(cims.df, ref.mz, norm.fac, scale.str) {
  ## 9. normalize processed CIMS data to a reference ion (typically 1
  ## million counts of the reagent ion); the reference ion can be
  ## scaled to a given parameter (e.g., absolute humidity)
  ##
  ## NB: see documentation of fProcessCIMS()
  ##
  ## input:
  ##    cims.df = data.frame of processed CIMS data
  ##    ref.mz = mass of reference ion (e.g., 127 for iodine)
  ##    norm.fac = normalization factor (e.g., 1 OR 1e6)
  ##    scale.str =  scaling parameter ("none" OR "vaisala" OR
  ##                 name of variable)
  ## output:
  ##    cims.out = data.frame ( time variables, normalized data,
  ##                            diagnostic variables, relative humidity,
  ##                            temperature, scaling parameter,
  ##                            background flag )
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## separate CIMS variables
  var.str <- colnames(cims.df)
  cims.time <- cims.df[,c("Datetime", "Date", "Time")]
  cims.amu <- cims.df[,grep("^amu", var.str)]
  cims.ic <- cims.df[,grep("^m", var.str)]
  cims.diagn <- cbind(cims.df[,grep("^sec", var.str)],
                      cims.df[,grep("^n", var.str)],
                      cims.df[,grep("^c", var.str)],
                      cims.df[,grep("^A", var.str)])
  cims.probe <- cims.df[,c("Vaias.RH", "Vaias.T")]
  cims.flag <- cims.df[,"Flag_Bgd", drop=F]
  ## set scaling parameter
  switch(scale.str,
         "none" = {     # no scaling (set to 1)
           scale.df <- data.frame(Flag_1 = rep(1, nrow(cims.time)))
         },
         "vaisala" = {  # absolute humidity from Vaisala probe (g/m3)
           probe.ah <- fHumid(cims.probe$Vaias.RH, "RH", "AH",
                              cims.probe$Vaias.T, 1.01325e+05)
           scale.df <- data.frame(Vaias.AH = probe.ah)
         },
         {              # other parameter
           scale.df <- data.frame(get(scale.str))
           colnames(scale.df) <- scale.str
         }
         )
  ## scale reference ion to scaling parameter
  ref.str <- paste("m", as.character(ref.mz), sep="")
  ref.ic <- cims.ic[,ref.str]
  ref.scal <- ref.ic / scale.df
  ref.scal[ref.scal == 0] <- NaN
  ## normalize data to reference ion
  cims.norm <- apply(cims.ic, 2, function(x)
                     x * norm.fac / ref.scal)
  cims.norm <- data.frame(cims.norm)
  ## rename normalized data variables
  colnames(cims.norm) <- paste(colnames(cims.ic), "norm", sep="_")
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.amu, cims.norm, cims.diagn,
                         cims.probe, cims.flag, scale.df)
  return(cims.out)
}
