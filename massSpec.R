### ---------------------------------------------------------------- ###
### functions for mass spectrometry:
### - fLoadTOF()     : load PTR-TOF-MS spectra
### - fNormTOF()     : normalize and average PTR-TOF-MS spectra
### - fPlotSpect()   : rotate spectra and make timeseries plots
### - fLoadCIMS()    : load CIMS data
### - fSpectraCIMS() : load CIMS spectra
### - fDiagnCIMS()   : run CIMS diagnostics
### - fProcessCIMS() : process CIMS data
### - fNormCIMS()    : normalize CIMS data
### - fBkgdCIMS()    : 
###
### version 4.1, Apr 2019
### author: RS
### ---------------------------------------------------------------- ###

fLoadTOF <- function(tof.dir, tof.fn) {
  ## load spectra file generated by the Leicester PTR-TOF-MS
  ##
  ## the PTR-TOF-MS spectra files have m/z on the first row and the
  ## ion counts of each scan in the following rows:
  ##
  ##     18        19        20      21
  ##    3880     112395     125     253
  ##    4469     107648     122     263
  ##    4942     106513     131     233
  ##
  ## input:
  ##     tof.dir = PTR-TOF spectra file directory
  ##     tof.fn = name of PTR-TOF spectra file
  ## output:
  ##     tof.out = data.frame ( mz, scan1, scan2, scan3, ... )
  ## ------------------------------------------------------------
  ## load PTR-TOF spectra file
  tof.file <- paste(tof.dir, tof.fn, sep="")
  tof.df <- read.table(tof.file, header=FALSE, sep=",")
  ## spectra header (first row)
  n.scan <- nrow(tof.df) - 1
  tof.ions <- paste("scan", seq(1, n.scan, by=1), sep="")
  tof.head <- c("mz", tof.ions)
  ## rotate PTR-TOF spectra data
  ## drop first column (m/z=0) and last column (blank)
  n.ion <- ncol(tof.df) - 1
  tof.matx <- t(tof.df[,2:n.ion])
  ## output data.frame
  cat("loaded:", tof.fn, "\n")
  tof.out <- data.frame(tof.matx) #!
  rownames(tof.out) <- NULL
  colnames(tof.out) <- tof.head
  return(tof.out)
}

fNormTOF <- function(spect.df, ref.mz, scan.ini, scan.fin) {
  ## normalize PTR-TOF-MS spectra to 1 million counts of a reference
  ## ion (e.g., [H3O]+)
  ## calculate average spectrum and standard deviation of a group of
  ## normalized scans
  ##
  ## NB: see documentation of fLoadTOF()
  ##
  ## input:
  ##     spect.df = data.frame of spectra (m/z, scan1, scan2, ...)
  ##     ref.mz = mass of reference ion
  ##     scan.ini = n. initial scans to exclude from average
  ##     scan.fin = n. final scans to exclude from average
  ## output:
  ##     spect.out = data.frame ( mz, scan1, scan2, ...,
  ##                              scan.avg, scan.std )
  ## ------------------------------------------------------------
  if (!is.data.frame(spect.df)) {
    df.name <- deparse(substitute(spect.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## reference ion count
  ref.r <- which(spect.df["mz"] == as.numeric(ref.mz))
  ref.ic <- as.numeric(spect.df[ref.r,])
  ## normalize spectra
  spect.norm <- t(apply(spect.df, 1, function(x) x * 1e6 / ref.ic)
                  )
  spect.norm[,1] <- spect.df[,1]
  nsp <- ncol(spect.norm)
  ## calculate average spectrum and standard deviation
  smin <- as.numeric(scan.ini) + 2
  smax <- nsp - as.numeric(scan.fin)
  spect.avg <- apply(spect.norm[,smin:smax], 1, mean)
  spect.std <- apply(spect.norm[,smin:smax], 1, sd)
  ## output data.frame
  spect.out <- as.data.frame(spect.norm) #!
  spect.out[,(nsp+1)] <- spect.avg
  spect.out[,(nsp+2)] <- spect.std
  colnames(spect.out)[(nsp+1)] <- "scan.avg"
  colnames(spect.out)[(nsp+2)] <- "scan.std"
  return(spect.out)
}

fPlotSpect <- function(spect.df, mz.min, mz.max, sc.min, sc.max, fn.str) {
  ## rotate data.frame of spectra and make plots of time spectra (ion
  ## counts vs. number of scans) for a given interval of masses
  ##
  ## optional: save plots of time spectra to pdf file
  ##
  ## input:
  ##     spect.df = data.frame ( mass, scan1, scan2, scan3, ... )
  ##     mz.min = smallest mass to plot
  ##     mz.max = largest mass to plot
  ##     sc.min = smallest mass to plot
  ##     sc.max = largest mass to plot
  ##     fn.str = name of png file to save plots OR ""
  ## output:
  ##     spect.out = data.frame ( n. scan, mass1, mass2, mass3, ... )
  ##     --> plot of time spectra
  ##     --> png file : `fn.str`.png
  ## ------------------------------------------------------------
  if (!is.data.frame(spect.df)) {
    df.name <- deparse(substitute(spect.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## rotate data.frame and add vector with scan number
  mz.vec <- spect.df[,1]
  spect.t <- t(spect.df[,-1])
  rownames(spect.t) <- NULL
  colnames(spect.t) <- paste("m", mz.vec, sep="")
  n.scan <- seq(1, nrow(spect.t), by=1)
  ## select range of masses
  mz.inter <- which((mz.vec > mz.min) & (mz.vec < mz.max))
  ## plot time spectra in 4x4 panels
  par(mfrow = c(4,4))
  for (i in mz.inter) {
      spect.ic <- spect.t[,i]
      if (all(is.na(spect.ic)) == FALSE) {  # time spectrum #!
          plot(n.scan, spect.ic, type="o", cex=0.6,
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      } else {                              # empty plot
          plot(0, 0, type="o", cex=0.6,
               xlim=c(-1,1), ylim=c(-1,1),
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      }
  }
  if (fn.str != "") {
    dev.copy(png, paste(fn.str, ".png", sep=""),
             width=297, height=210, units="mm", res=150)
    dev.off()
  }
  ## output data.frame
  spect.out <- as.data.frame(cbind(n.scan, spect.t)) #!
  return(spect.out)
}

fLoadCIMS <- function(cims.dir, cims.fn) {
  ## Load data file generated by the Leicester CIMS.
  ##
  ## The CIMS data files have the format:
  ##
  ##    time, year, month, day, hour, minute, second
  ##    number of signals, instrument cycles
  ##    ion count per second, mass, dwell time
  ##    analog signals (flows, pressures, voltages)
  ##
  ## input:
  ##     cims.dir = CIMS data file directory
  ##     cims.fn = name of CIMS data file
  ## output:
  ##     cims.out = data.frame ( time variables, data variables,
  ##                             diagnostic variables )
  ## ------------------------------------------------------------
  ## load CIMS data file
  cims.file <- paste(cims.dir, cims.fn, sep="")
  cims.df <- read.table(cims.file, header=TRUE, sep="")
  ## drop last row of the file
  cims.df <- cims.df[-nrow(cims.df),]
  ## separate CIMS variables into groups
  nvar <- length(colnames(cims.df))
  cims1 <- cims.df[,1:8]             # time
  cims2 <- cims.df[,9:11]            # n. cycles, mass channels, analog signals
  cims3 <- cims.df[,12:15]           # cycles
  cims4 <- cims.df[,16:(nvar-32)]    # Hz, mass, dwell time
  cims5 <- cims.df[,(nvar-31):nvar]  # analog signals
  ## convert date/time strings to chron
  tst.d <- paste(cims1$yr, cims1$mo, cims1$dm, sep="-")
  tst.t <- paste(cims1$hr, cims1$mn, cims1$sc, sep=":")
  tst.dt <- paste(tst.d, tst.t, sep=" ")
  cims.d <- fChronStr(tst.d, "y-m-d")
  cims.t <- fChronStr(tst.t, "h:m:s")
  cims.dt <- fChronStr(tst.dt, "y-m-d h:m:s")
  cims.time <- data.frame(cims.dt, cims.d, cims.t)
  rownames(cims.time) <- NULL
  colnames(cims.time) <- c("Datetime", "Date", "Time")
  ## output data.frame
  cat("loaded:", cims.fn)
  cat(" [", as.character(cims2$nh[1]), "mass channels ]\n")
  cims.out <- data.frame(cims.time, cims4, cims2, cims3, cims5)
  return(cims.out)
}

fSpectraCIMS <- function(cims.dir, cims.lst) {
  ## Load spectra files generated by the Leicester CIMS. Extract the
  ## start/stop times of each spectrum.
  ##
  ## input:
  ##     cims.dir = CIMS spectra files directory
  ##     cims.lst = list of CIMS spectra files
  ## output:
  ##     cims.out = list ( data.frame ( start chron, stop chron ),
  ##                       data.frame ( amu, scan1, scan2, ... ) )
  ## ------------------------------------------------------------
  if (!is.list(cims.lst)) {
    lst.name <- deparse(substitute(cims.lst))
    stop(paste(lst.name, "must be a list", sep=" "))
  }
  ## initialize lists and chron variables
  scan.lst <- list()
  scan.name <- list()
  scan.start <- chron(format=c(dates="d-m-y", times="h:m:s"))
  scan.stop <- chron(format=c(dates="d-m-y", times="h:m:s"))
  ## load all CIMS spectra
  for (i in 1:length(cims.lst)) {
    ## load spectrum
    cims.fn <- cims.lst[[i]]
    cims.df <- fLoadCIMS(cims.dir, cims.fn)
    ## spectrum data (mass, ion count)
    cims.ic <- data.frame(amu = (cims.df[,5] / 1000),
                          ic = cims.df[,4])
    scan.lst[[i]] <- cims.ic
    ## name of spectrum file: `filename_S_yyyy-mm-dd_hh-mm-ss.txt`
    n.fn <- nchar(cims.fn)
    cims.str <- gsub("-", "", substr(cims.fn, n.fn-18, n.fn-7))
    scan.name[[i]] <- paste("_", cims.str, sep="")
    ## spectrum start/stop times
    cims.dt <- cims.df$Datetime
    scan.start[i] <- cims.dt[1]
    scan.stop[i] <- cims.dt[length(cims.dt)]
  }
  ## data.frame of spectra start/stop times
  scan.tst <- data.frame(StartTime = scan.start,
                         StopTime = scan.stop)
  ## data.frame of spectra
  if (length(scan.name) == 1) {
    scan.df <- scan.lst[[1]]
    colnames(scan.df) <- c("amu", paste("ic", scan.name[[1]], sep=""))
  } else {
    scan.df <- fMergeDF(scan.lst, "amu", "TRUE", scan.name)
  }
  ## output list:
  ## [1] data.frame of spectra start/stop times
  ## [2] data.frame of spectra
  cims.out <- list(scan.tst, scan.df)
  return(cims.out)
}

fDiagnCIMS <- function(cims.df, fn.str) {
  ## run basic diagnostics on CIMS data and make plot of diagnostic
  ## variables with reference values
  ##
  ## optional: save plots of diagnostic variables to png file
  ##
  ## NB: see documentation of fLoadCIMS()
  ##
  ## input:
  ##     cims.df = data.frame of CIMS data
  ##     fn.str = name of png file to save plots OR ""
  ## output:
  ##     --> plot of diagnostic variables
  ##     --> png file : `fn.str`.png
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## set diagnostic variables
  t.stamp <- cims.df$Datetime  # timestamp
  n.cyc <- cims.df$nc          # n. cycles
  n.hop <- cims.df$nh          # n. mass channels
  n.ans <- cims.df$na          # n. analog signals
  cyc.0 <- cims.df$cB          # flag x cycle B (Background)
  cyc.1 <- cims.df$cC          # flag x cycle C (Background)
  cyc.2 <- cims.df$c2          # flag x cycle 2 - NOT USED
  cyc.3 <- cims.df$c3          # flag x cycle 3 - NOT USED
  fptv.a01 <- cims.df$A01      # MFC 1 - NOT USED
  fptv.a02 <- cims.df$A02      # MFC 2 (CH3I flow)
  fptv.a05 <- cims.df$A05      # relative humidity (T/RH probe)
  fptv.a06 <- cims.df$A06      # temperature (T/RH probe)
  fptv.a07 <- cims.df$A07      # MFC 7 (N2 flow)
  fptv.a08 <- cims.df$A08      # FT pressure
  hv.a01 <- cims.df$A17        # pinhole
  hv.a06 <- cims.df$A22        # octopole plate
  hv.a07 <- cims.df$A23        # CDC DC
  hv.a08 <- cims.df$A24        # CDC RF
  hv.a09 <- cims.df$A25        # octopole RF
  hv.a10 <- cims.df$A26        # octopole DC
  hv.b05 <- cims.df$A30        # CDC pressure
  hv.b06 <- cims.df$A31        # Main pressure
  hv.b07 <- cims.df$A32        # Quad pressure
  # !!! TODO
  ## cims.data <- cbind(cims.df[,grep("^Hz", var.str)],
  ##                    cims.df[,grep("^mamu", var.str)],
  ##                    cims.df[,grep("^ms", var.str)])
  ## ## monitored masses and dwell times
  ## print(colMeans(cims.amu, na.rm=TRUE))
  ## print(colMeans(cims.sec, na.rm=TRUE))
  ## check consistency of parameters and flags
  if (length(unique(n.cyc)) != 1) {
    cat("CONFLICT! n. cycles:", unique(n.cyc), "\n")
  }
  if (length(unique(n.hop)) != 1) {
    cat("CONFLICT! n. mass channels:", unique(n.hop), "\n")
  }
  if (length(unique(n.ans)) != 1) {
    cat("CONFLICT! n. analog signals:", unique(n.ans), "\n")
  }
  if (length(unique(cyc.0)) != 1 & length(unique(cyc.0)) != 2) {
    cat("CONFLICT! flag x cycle B:", unique(cyc.0), "\n")
  }
  if (length(unique(cyc.1)) != 1 & length(unique(cyc.1)) != 2) {
    cat("CONFLICT! flag x cycle C:", unique(cyc.1), "\n")
  }
  if (length(unique(cyc.2)) != 1) {
    cat("CONFLICT! flag x cycle 2:", unique(cyc.2), "\n")
  }
  if (length(unique(cyc.3)) != 1) {
    cat("CONFLICT! flag x cycle 3:", unique(cyc.3), "\n")
  }
  if (identical(cyc.0, cyc.1) != TRUE) {
    cat("CONFLICT! flags x background cycles:", unique(cyc.0), "\n")
  }
  ## make plot of diagnostic variables with reference values
  par(mfrow = c(3,4), bg="white")
  plot(t.stamp, fptv.a02, type="l", ylim=c(400,600),
       xlab="time", ylab="mV", main="MeI flow")
  lines(t.stamp, rep(500, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, fptv.a07, type="l", ylim=c(1900,2100),
       xlab="time", ylab="mV", main="N2 flow")
  lines(t.stamp, rep(2000, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a01, type="l", ylim=c(-300,-180),
       xlab="time", ylab="mV", main="pinhole")
  lines(t.stamp, rep(-250, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a06, type="l", ylim=c(0,150),
       xlab="time", ylab="mV", main="octopole plate")
  lines(t.stamp, rep(67, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a07, type="l", ylim=c(-100,50),
       xlab="time", ylab="mV", main="CDC DC")
  lines(t.stamp, rep(-46, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a08, type="l", ylim=c(1700,1900),
       xlab="time", ylab="mV", main="CDC RF")
  lines(t.stamp, rep(1850, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a09, type="l", ylim=c(1000,3000),
       xlab="time", ylab="mV", main="octopole RF")
  lines(t.stamp, rep(1900, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, hv.a10, type="l", ylim=c(400,800),
       xlab="time", ylab="mV", main="octopole DC")
  lines(t.stamp, rep(496, length(t.stamp)), lty=2, lwd=3, col="red")
  grid()
  plot(t.stamp, fptv.a08, type="l", ylim=c(700,1400),
       xlab="time", ylab="mV", main="FT pressure")
  grid()
  plot(t.stamp, hv.b05, type="l", ylim=c(5500,5900),
       xlab="time", ylab="mV", main="CDC pressure")
  grid()
  plot(t.stamp, hv.b06, type="l", ylim=c(3500,3900),
       xlab="time", ylab="mV", main="Main pressure")
  grid()
  plot(t.stamp, hv.b07, type="l", ylim=c(1800,2100),
       xlab="time", ylab="mV", main="Quad pressure")
  grid()
  ## png file to save plots
  if (fn.str != "") {
    dev.copy(png, paste(fn.str, ".png", sep=""),
             width=297, height=210, units="mm", res=150)
    dev.off()
  }
}

fProcessCIMS <- function(cims.df, bkgd.set) {
  ## Process the Leicester CIMS raw data:
  ## * convert and rename data and diagnostic variables
  ## * calculate temperature and humidity of the calibration flow
  ## * create instrument background flag
  ##
  ## NB: use fLoadCIMS() to import the CIMS data files and generate
  ## the data.frame of CIMS data.
  ##
  ## input:
  ##     cims.df = data.frame of CIMS data
  ##     bkgd.set = instrument background setting ("on" OR "off")
  ## output:
  ##     cims.out = data.frame ( time variables, processed data,
  ##                             diagnostic variables, relative humidity,
  ##                             temperature, background flag )
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## separate time, data and diagnostic variables
  var.str <- colnames(cims.df)
  cims.time <- cims.df[,c("Datetime", "Date", "Time")]
  cims.data <- cbind(cims.df[,grep("^Hz", var.str)],
                     cims.df[,grep("^mamu", var.str)],
                     cims.df[,grep("^ms", var.str)])
  cims.diagn <- cbind(cims.df[,grep("^n", var.str)],
                      cims.df[,grep("^c", var.str)],
                      cims.df[,grep("^A", var.str)])
  ## ion count (Hz), atomic mass (amu), dwell time (sec)
  n.mz <- length(colnames(cims.data)) / 3
  ic.hz <- cims.data[,1:n.mz]
  ic.am <- cims.data[,(n.mz+1):(2*n.mz)]
  ic.ms <- cims.data[,(2*n.mz+1):(3*n.mz)]
  cims.ic <- ic.hz
  cims.amu <- ic.am / 1000
  cims.sec <- ic.ms / 1000
  colnames(cims.ic) <- gsub("Hz", "m", colnames(cims.ic))
  colnames(cims.amu) <- gsub("mamu", "amu", colnames(cims.amu))
  colnames(cims.sec) <- gsub("ms", "sec", colnames(cims.sec))
  ## calculate temperature (C) and relative humidity (%) of the
  ## calibration flow:
  ## * A05 = humidity analog signal
  ## * A06 = temperature analog signal
  ## NB: the conversion factors are for the Vaisala HMP110 probe
  probe.rh <- (cims.diagn$A05 / 1000) * 20
  probe.temp <- (cims.diagn$A06 / 1000) * 30 - 70
  cims.probe <- data.frame(probe_RH = probe.rh, probe_T = probe.temp)
  ## create instrument background flag:
  ##  0 = signal
  ## -1 = before/after valve switch
  ##  1 = background signal
  cims.flag <- rep(0, nrow(cims.time))
  if (bkgd.set == "on") {
    ## drop 10 data points before/after valve switch
    cims.diagn1 <- fSwitchFlag(cims.diagn, "cB", 1, 10, 10)
    cims.flag <- cims.diagn1$Flag
  }
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.amu, cims.ic, cims.sec,
                         cims.diagn, cims.probe,
                         Flag_Bgd = cims.flag)
  return(cims.out)
}

fNormCIMS <- function(cims.df, ref.mz, norm.fac, scale.str) {
  ## Normalize the Leicester CIMS processed data to a reference ion.
  ## Standard practice is to normalize the CIMS data to 1 million
  ## counts of the reagent ion (e.g., iodide). Optionally, the
  ## reference ion can be scaled to the absolute humidity of the
  ## calibration flow ("AH").
  ##
  ## NB: use fProcessCIMS() to process the raw CIMS data before
  ## normalizing with fNormCIMS().
  ##
  ## input:
  ##     cims.df = data.frame of processed CIMS data
  ##     ref.mz = mass of reference ion
  ##     norm.fac = normalization factor (1 OR 1e6)
  ##     scale.str = scaling parameter ("none" OR "AH")
  ## output:
  ##     cims.out = data.frame ( time variables, normalized data,
  ##                             diagnostic variables, t/rh variables,
  ##                             scaling parameter, background flag )
  ## ------------------------------------------------------------
  if (!is.data.frame(cims.df)) {
    df.name <- deparse(substitute(cims.df))
    stop(paste(df.name, "must be a data.frame", sep=" "))
  }
  ## separate time, ion counts and other variables
  var.str <- colnames(cims.df)
  cims.time <- cims.df[,c("Datetime", "Date", "Time")]
  cims.ic <- cims.df[,grep("^m", var.str)]
  cims.var1 <- cbind(cims.df[,grep("^amu", var.str)],
                     cims.df[,grep("^sec", var.str)],
                     cims.df[,grep("^n", var.str)],
                     cims.df[,grep("^c", var.str)],
                     cims.df[,grep("^A", var.str)])
  cims.var2 <- cims.df[,c("probe_RH", "probe_T", "Flag_Bgd")]
  ## convert relative humidity (%) to absolute humidity (g/m3)
  ## NB: assume standard pressure (1 atm = 1013.25 mbar)
  probe.ah <- fHumid(cims.var2$probe_RH, "RH", "AH", cims.var2$probe_T, 1.01325e+05)
  ## get reference ion counts
  ref.str <- paste("m", as.character(ref.mz), sep="")
  ref.ic <- cims.ic[,ref.str]
  ## scaling parameter for the reference ion
  switch(scale.str,
         "none" = {  # no scaling
           ref.ion <- ref.ic
         },
         "AH" = {    # scale to absolute humidity
           ref.ion <- ref.ic / probe.ah
         },
         stop("INPUT ERROR: invalid parameter")
         )
  ## normalize data to reference ion
  ref.ion[ref.ion == 0] <- NaN
  cims.norm <- apply(cims.ic, 2, function(x) x * norm.fac / ref.ion)
  ## rename normalized data variables
  colnames(cims.norm) <- paste(colnames(cims.ic), "ncps", sep="_")
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.norm, cims.var1, cims.var2)
  return(cims.out)
}
