### ---------------------------------------------------------------- ###
### functions for mass spectrometry:
###  1.
###  2. load PTR-TOF spectra
###  3. normalize and average PTR-TOF spectra
###  4. rotate spectra and make time spectra plots
###  5. load CIMS data
###  6. load CIMS spectra
###  7. process and normalize CIMS data
###
### version 2.9, Mar 2015
### author: RS
### ---------------------------------------------------------------- ###

fLoadTOF <- function(spect.dir, spect.name) {
  ## 2. load spectra file generated by PTR-TOF instrument
  ##
  ## spectra files are in CSV format:
  ##   scan n.     m/z         m/z         m/z
  ##     0          1           2           3
  ##     1       ion count   ion count   ion count
  ##     2       ion count   ion count   ion count
  ##
  ## input:
  ##    spect.dir = PTR-TOF spectra file directory
  ##    spect.name = name of PTR-TOF spectra file
  ## output:
  ##    spect.out = data.frame ( mz, scan1, scan2, scan3, ... )
  ## ------------------------------------------------------------
  ## load spectra file
  spect.file <- paste(spect.dir, spect.name, sep="")
  spect.data <- read.delim(spect.file, header=FALSE, sep=",")
  ## spectra header (first row of file)
  n.scan <- nrow(spect.data) - 1
  spect.ions <- paste("scan", seq(1, n.scan, by=1), sep="")
  spect.head <- c("mz", spect.ions)
  ## spectra data (drop first and last columns)
  n.ion <- ncol(spect.data) - 1
  spect.matx <- t(spect.data[,2:n.ion])
  ## output data.frame
  spect.out <- data.frame(spect.matx)
  rownames(spect.out) <- NULL
  colnames(spect.out) <- spect.head
  return(spect.out)
}

fNormTOF <- function(spect.df, scan.ini, scan.fin) {
  ## 3. normalize PTR-TOF spectra to 1 million counts of hydronium
  ## (H3O+); calculate average spectrum and standard deviation of a
  ## group of normalized scans
  ##
  ## input:
  ##    spect.df = data.frame of spectra (m/z, scan1, scan2, ...)
  ##    scan.ini = n. initial scans to exclude from average
  ##    scan.fin = n. final scans to exclude from average
  ## output:
  ##    spect.out = data.frame ( mz, scan1, scan2, ...,
  ##                             scan.avg, scan.std )
  ## ------------------------------------------------------------
  ## hydronium (m/z=19) ion count
  h3o <- as.numeric(spect.df[19,])
  ## normalize spectra
  spect.norm <- t(apply( spect.df, 1, function(x)
                         x * 1e6 / h3o ))
  spect.norm[,1] <- spect.df[,1]
  nsp <- ncol(spect.norm)
  ## calculate average spectrum and standard deviation
  smin <- scan.ini + 2
  smax <- nsp - scan.fin
  spect.avg <- apply( spect.norm[,smin:smax], 1, mean )
  spect.std <- apply( spect.norm[,smin:smax], 1, sd )
  ## output data.frame
  spect.out <- as.data.frame(spect.norm)
  spect.out[,(nsp+1)] <- spect.avg
  spect.out[,(nsp+2)] <- spect.std
  colnames(spect.out)[(nsp+1)] <- "scan.avg"
  colnames(spect.out)[(nsp+2)] <- "scan.std"
  return(spect.out)
}

fPlotSpect <- function(spect.df, mz.min, mz.max) {
  ## 4. rotate data.frame of spectra; make plots of time spectra
  ## (ion counts vs. number of scans) for a given interval of masses
  ## and save plots to pdf file
  ##
  ## input:
  ##    spect.df = data.frame ( mass, scan1, scan2, scan3, ... )
  ##    mz.min = smallest mass to plot
  ##    mz.max = largest mass to plot
  ## output:
  ##    spect.out = data.frame ( n. scan, mass1, mass2, mass3, ... )
  ##    ---> pdf file : <spect.df>.pdf
  ## ------------------------------------------------------------
  ## rotate data.frame and add a vector with scan number
  mz.vec <- spect.df[,1]
  spect.t <- t(spect.df[,-1])
  rownames(spect.t) <- NULL
  colnames(spect.t) <- paste("m", mz.vec, sep="")
  n.scan <- seq(1, nrow(spect.t), by=1)
  ## selected range of masses
  mz.inter <- which((mz.vec > mz.min) & (mz.vec < mz.max))
  ## plot time spectra in 4x4 panels
  pdf(paste(deparse(substitute(spect.df)), ".pdf", sep=""))
  par(mfrow = c(4,4))
  for (i in mz.inter) {
      spect.ic <- spect.t[,i]
      if (all(is.na(spect.ic)) == FALSE) {  # time spectrum
          plot(n.scan, spect.ic, type="o", cex=0.6,
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      } else {                              # empty plot
          plot(0, 0, type="o", cex=0.6,
               xlim=c(-1,1), ylim=c(-1,1),
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      }
  }
  dev.off()
  ## output data.frame
  spect.out <- as.data.frame(cbind(n.scan, spect.t))
  return(spect.out)
}

fLoadCIMS <- function(cims.dir, cims.fn) {
  ## 5. load data file generated by CIMS instrument
  ##
  ## input:
  ##    cims.dir = CIMS data file directory
  ##    cims.fn = name of CIMS data file
  ## output:
  ##    cims.out = data.frame ( time variables, data variables,
  ##                            diagnostic variables )
  ## ------------------------------------------------------------
  ## load CIMS data file (drop last row)
  cims.file <- paste(cims.dir, cims.fn, sep="")
  cims.df <- read.delim(cims.file, header=TRUE, sep="")
  cims.df <- cims.df[-nrow(cims.df),]
  ## separate variables into groups
  nvar <- length(names(cims.df))
  cims1 <- cims.df[,1:8]             # time
  cims2 <- cims.df[,9:11]            # n. cycles, hops, analog signals
  cims3 <- cims.df[,12:15]           # cycles
  cims4 <- cims.df[,16:(nvar-32)]    # Hz, mass, dwell time
  cims5 <- cims.df[,(nvar-31):nvar]  # analog signals
  ## convert date/time strings to chron
  tst.d <- paste(cims1$yr, cims1$mo, cims1$dm, sep="-")
  tst.t <- paste(cims1$hr, cims1$mn, cims1$sc, sep=":")
  tst.dt <- paste(tst.d, tst.t, sep=" ")
  cims.d <- fChronStr(tst.d, "y-m-d")
  cims.t <- fChronStr(tst.t, "h:m:s")
  cims.dt <- fChronStr(tst.dt, "y-m-d h:m:s")
  cims.time <- cbind.data.frame(cims.dt, cims.d, cims.t)
  rownames(cims.time) <- NULL
  colnames(cims.time) <- c("Datetime", "Date", "Time")
  ## output data.frame
  cims.out <- data.frame(cims.time, cims4, cims2, cims3, cims5)
  return(cims.out)
}

fSpectraCIMS <- function(cims.dir, cims.lst) {
  ## 6. load spectra files generated by CIMS instrument
  ##
  ## input:
  ##    cims.dir = CIMS spectra files directory
  ##    cims.lst = list of CIMS spectra filenames
  ## output:
  ##    spect.out = list ( data.frame ( start chron, stop chron )
  ##                       data.frame ( amu, ic_mmdd_hhmm, ... ) )
  ## ------------------------------------------------------------
  ## initialize lists and chron vectors
  spectra.list <- list()
  spectra.name <- list()
  spectra.start <- chron(format=c(dates="d-m-y", times="h:m:s"))
  spectra.stop <- chron(format=c(dates="d-m-y", times="h:m:s"))
  ## load spectra files
  for (i in 1:length(cims.lst)) {
    cims.fn <- cims.lst[[i]]
    cat("loading:", cims.fn, "\n")
    spect.data <- fLoadCIMS(cims.dir, cims.fn)
    ## extract mass and ion count and add to list
    spect.ic <- data.frame(amu = spect.data$amu,
                           ic = spect.data$Hz)
    spectra.list[[i]] <- spect.ic
    ## get spectrum name ('_mmdd_hhmm') and add to list
    spect.str <- gsub("-", "", substr(cims.fn, 13, 23))
    spectra.name[[i]] <- paste("_", spect.str, sep="")
    ## get spectrum start/stop datetime
    spect.dt <- spect.data$Datetime
    spectra.start[i] <- spect.dt[1]
    spectra.stop[i] <- spect.dt[length(spect.dt)]
  }
  ## spectra start/stop timestamp
  spectra.tst <- data.frame(StartTime = spectra.start,
                            StopTime = spectra.stop)
  ## merged spectra data.frame
  if (length(spectra.name) == 1) {
    spectra.df <- spectra.list[[1]]
    colnames(spectra.df) <- c("amu", paste("ic", spectra.name[[1]], sep=""))
  } else {
    spectra.df <- fMergeDF(spectra.list, "amu", "TRUE", spectra.name)
  }
  ## output list
  spect.out <- list(spectra.tst, spectra.df)
  return(spect.out)
}

fProcessCIMS <- function(cims.df, norm.mz, norm.fac) {
  ## 7. process CIMS data, then normalize to a reference ion
  ##
  ## input:
  ##    cims.df = data.frame of CIMS data
  ##    norm.mz = mass of reference ion
  ##    norm.fac = normalization factor (eg: 1 OR 1e6)
  ## output:
  ##    cims.out = data.frame ( time variables, processed data variables,
  ##                            normalized data, diagnostic variables,
  ##                            relative humidity, temperature)
  ## ------------------------------------------------------------
  ## separate variables
  nvar <- ncol(cims.df)
  nhop <- cims.df$nh[1]
  ndat <- nhop*3
  cims.time <- cims.df[,1:3]
  cims.data <- cims.df[,4:(3+ndat)]
  cims.diag <- cims.df[,(4+ndat):nvar]
  ## calculate atomic mass unit (amu) and total ion count
  ic.hz <- cims.data[,seq(1, ndat, by=3), drop=F]
  ic.am <- cims.data[,seq(2, ndat, by=3), drop=F]
  ic.ms <- cims.data[,seq(3, ndat, by=3), drop=F]
  cims.amu <- ic.am / 1000
  cims.ic <- ic.hz * (ic.ms / 1000)
  colnames(cims.amu) <- gsub("mamu", "amu", colnames(cims.amu))
  colnames(cims.ic) <- gsub("Hz", "m", colnames(cims.ic))
  colnames(cims.ic) <- paste(colnames(cims.ic), "_raw", sep="")
  ## get reference ion count
  norm.str <- paste("m", as.character(norm.mz), "_raw", sep="")
  norm.ic <- cims.ic[,norm.str]
  ## normalize data to reference ion count
  cims.norm1 <- apply( cims.ic, 2, function(x)
                       x * norm.fac / norm.ic )
  cims.norm2 <- apply( cims.norm1, 2, function(x)
                       ifelse(is.infinite(x) == TRUE, NA, x) )
  colnames(cims.norm2) <- gsub("_raw", "_norm", colnames(cims.norm2))
  ## temperature and relative humidity from Vaisala probe
  probe.rh <- (cims.diag$A05/1000)*20
  probe.temp <- (cims.diag$A06/1000)*30 - 70
  cims.probe <- data.frame(RH = probe.rh, Temp = probe.temp)
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.amu, cims.ic,
                         cims.norm2, cims.diag, cims.probe)
  return(cims.out)
}
