### ---------------------------------------------------------------- ###
### functions for mass spectrometry:
###  2. load PTR-TOF spectra
###  3. normalize and average PTR-TOF spectra
###  4. rotate spectra and make time spectra plots
###  5. load CIMS data
###  6. load CIMS spectra
###  7. run CIMS diagnostics
###  8. process CIMS data
###
### version 2.5, May 2014
### author: RS
### ---------------------------------------------------------------- ###

fLoadTOF <- function(spect.dir, spect.name) {
  ## 2. load spectra file generated by PTR-TOF instrument
  ##
  ## spectra files are in CSV format:
  ##   scan n.    m/z        m/z        m/z
  ##     0         1          2          3
  ##     1       counts     counts     counts
  ##
  ## input:
  ##       spect.dir = PTR-TOF spectra file directory
  ##       spect.name = name of PTR-TOF spectra file
  ## output:
  ##        data.frame ( mz, scan1, scan2, scan3, ... )
  ## ------------------------------------------------------------
  ## load spectra file
  spect.file <- paste(spect.dir, spect.name, sep="")
  spect.data <- read.delim(spect.file, header=FALSE, sep=",")
  ## spectra header (first row of file)
  n.scan <- nrow(spect.data) - 1
  spect.ions <- paste("scan", seq(1, n.scan, by=1), sep="")
  spect.head <- c("mz", spect.ions)
  ## spectra data (drop first and last columns)
  n.ion <- ncol(spect.data) - 1
  spect.matx <- t(spect.data[,2:n.ion])
  ## output data.frame
  spect.out <- data.frame(spect.matx)
  rownames(spect.out) <- NULL
  colnames(spect.out) <- spect.head
  return(spect.out)
}

fNormTOF <- function(spect.df, scan.ini, scan.fin) {
  ## 3. normalize PTR-TOF spectra to 1 million counts of hydronium
  ## (H3O+); calculate average spectrum and standard deviation of a
  ## group of normalized scans
  ##
  ## input:
  ##       spect.df = data.frame of spectra (m/z, scan1, scan2, ...)
  ##       scan.ini = n. initial scans to exclude from average
  ##       scan.fin = n. final scans to exclude from average
  ## output:
  ##        data.frame ( mz, scan1, scan2, ..., scan.avg, scan.std )
  ## ------------------------------------------------------------
  ## hydronium (m/z=19) ion count
  h3o <- as.numeric(spect.df[19,])
  ## normalize spectra
  spect.norm <- t(apply( spect.df, 1, function(x)
                         x * 1e6 / h3o ))
  spect.norm[,1] <- spect.df[,1]
  nsp <- ncol(spect.norm)
  ## calculate average spectrum and standard deviation
  smin <- scan.ini + 2
  smax <- nsp - scan.fin
  spect.avg <- apply( spect.norm[,smin:smax], 1, mean )
  spect.std <- apply( spect.norm[,smin:smax], 1, sd )
  ## output data.frame
  spect.out <- as.data.frame(spect.norm)
  spect.out[,(nsp+1)] <- spect.avg
  spect.out[,(nsp+2)] <- spect.std
  colnames(spect.out)[(nsp+1)] <- "scan.avg"
  colnames(spect.out)[(nsp+2)] <- "scan.std"
  return(spect.out)
}

fPlotSpect <- function(spect.df, mz.min, mz.max) {
  ## 4. rotate data.frame of spectra; make plots of time spectra
  ## (ion counts vs. number of scans) for a given interval of masses
  ## and save plots to pdf file
  ##
  ## input:
  ##       spect.df = data.frame ( mass, scan1, scan2, scan3, ... )
  ##       mz.min = smallest mass to plot
  ##       mz.max = largest mass to plot
  ## output:
  ##        data.frame ( n. scan, mass1, mass2, mass3, ... )
  ##        ---> pdf file (`spect.df'.pdf)
  ## ------------------------------------------------------------
  ## rotate data.frame and add a vector with scan number
  mz.vec <- spect.df[,1]
  spect.t <- t(spect.df[,-1])
  rownames(spect.t) <- NULL
  colnames(spect.t) <- paste("m", mz.vec, sep="")
  n.scan <- seq(1, nrow(spect.t), by=1)
  ## selected range of masses
  mz.inter <- which((mz.vec > mz.min) & (mz.vec < mz.max))
  ## plot time spectra in 4x4 panels
  pdf(paste(deparse(substitute(spect.df)), ".pdf", sep=""))
  par(mfrow = c(4,4))
  for (i in mz.inter) {
      spect.ic <- spect.t[,i]
      if (all(is.na(spect.ic)) == FALSE) {  # time spectrum
          plot(n.scan, spect.ic, type="o", cex=0.6,
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      } else {                              # empty plot
          plot(0, 0, type="o", cex=0.6,
               xlim=c(-1,1), ylim=c(-1,1),
               main=paste("mass ", mz.vec[i], sep=""),
               xlab="scan n.", ylab="ion count")
      }
  }
  dev.off()
  ## output data.frame
  spect.out <- as.data.frame(cbind(n.scan, spect.t))
  return(spect.out)
}

fLoadCIMS <- function(cims.dir, cims.fn) {
  ## 5. load data file generated by CIMS instrument
  ##
  ## input:
  ##       cims.dir = CIMS data file directory
  ##       cims.fn = name of CIMS data file
  ## output:
  ##        data.frame ( time variables, data variables,
  ##                     diagnostic variables )
  ## ------------------------------------------------------------
  ## load CIMS data file (drop last row)
  cims.file <- paste(cims.dir, cims.fn, sep="")
  cims.df <- read.delim(cims.file, header=TRUE, sep="")
  cims.df <- cims.df[-nrow(cims.df),]
  ## separate data in groups of variables
  nvar <- length(names(cims.df))
  cims1 <- cims.df[,1:8]             # time
  cims2 <- cims.df[,9:11]            # n. cycles, masses, analog signals
  cims3 <- cims.df[,12:15]           # cycles
  cims4 <- cims.df[,16:(nvar-32)]    # Hz, mass, dwell time
  cims5 <- cims.df[,(nvar-31):nvar]  # analog signals
  ## timestamp
  tst.d <- paste(cims1$yr, cims1$mo, cims1$dm, sep="-")
  tst.t <- paste(cims1$hr, cims1$mn, cims1$sc, sep=":")
  tst.dt <- paste(tst.d, tst.t, sep=" ")
  cims.d <- fChronStr(tst.d , "y-m-d", "")
  cims.t <- fChronStr(tst.t , "", "h:m:s")
  cims.dt <- fChronStr(tst.dt , "y-m-d", "h:m:s")
  cims.time <- cbind.data.frame(cims.dt, cims.d, cims.t)
  rownames(cims.time) <- NULL
  colnames(cims.time) <- c("Datetime", "Date", "Time")
  ## atomic mass unit (amu) and ion count
  nmz <- length(names(cims4))
  ic.hz <- cims4[,seq(1, nmz, by=3), drop=F]
  ic.am <- cims4[,seq(2, nmz, by=3), drop=F]
  ic.ms <- cims4[,seq(3, nmz, by=3), drop=F]
  cims.amu <- ic.am / 1000
  cims.ic <- ic.hz * ic.ms / 1000
  ## name of variables
  if (ncol(ic.am) == 1) {  # instrument in 'scan' mode
    colnames(cims.amu) <- "amu"
    colnames(cims.ic) <- "Hz"
  } else {                 # instrument in 'hop' mode
    colnames(cims.amu) <- gsub("mamu", "amu", colnames(cims.amu))
  }
  ## mass assignment correction   <---------------- !!!
  cims.amu.corr <- cims.amu + (-0.005279 * cims.amu + 0.854465)
  colnames(cims.amu) <- paste(colnames(cims.amu), ".raw", sep="")
  cims.data <- cbind.data.frame(cims.ic, cims.amu, cims.amu.corr)
  ## diagnostics variables
  tst.uxt <- cims1[,1:2, drop=F]
  cims5.v <- cims5/1000
  cims.diagn <- cbind.data.frame(tst.uxt, cims2, cims3, cims5.v)
  ## output data.frame
  cims.out <- data.frame(cims.time, cims.data, cims.diagn)
  return(cims.out)
}

fSpectraCIMS <- function(cims.dir, cims.lst) {
  ## 6. load spectra files generated by CIMS instrument
  ##
  ## input:
  ##       cims.dir = CIMS spectra files directory
  ##       cims.lst = list of CIMS spectra filenames
  ## output:
  ##        list ( data.frame ( start chron, stop chron )
  ##               data.frame ( amu, ic_mmdd_hhmm, ... ) )
  ## ------------------------------------------------------------
  ## initialize lists and chron vectors
  spectra.list <- list()
  spectra.name <- list()
  spectra.start <- chron(format=c(dates="d-m-y", times="h:m:s"))
  spectra.stop <- chron(format=c(dates="d-m-y", times="h:m:s"))
  ## load spectra files
  for (i in 1:length(cims.lst)) {
    cims.fn <- cims.lst[[i]]
    cat("loading:", cims.fn, "\n")
    spect.data <- fLoadCIMS(cims.dir, cims.fn)
    ## extract mass and ion count and add to list
    spect.ic <- data.frame(amu = spect.data$amu,
                           ic = spect.data$Hz)
    spectra.list[[i]] <- spect.ic
    ## get spectrum name ('_mmdd_hhmm') and add to list
    spect.str <- gsub("-", "", substr(cims.fn, 13, 23))
    spectra.name[[i]] <- paste("_", spect.str, sep="")
    ## get spectrum start/stop datetime
    spect.dt <- spect.data$Datetime
    spectra.start[i] <- spect.dt[1]
    spectra.stop[i] <- spect.dt[length(spect.dt)]
  }
  ## spectra start/stop timestamp
  spectra.tst <- data.frame(StartTime = spectra.start,
                            StopTime = spectra.stop)
  ## merged spectra data.frame
  if (length(spectra.name) == 1) {
    spectra.df <- spectra.list[[1]]
    colnames(spectra.df) <- c("amu", paste("ic", spectra.name[[1]], sep=""))
  } else {
    spectra.df <- fMergeDF(spectra.list, "amu", "TRUE", spectra.name)
  }
  ## output list
  spect.out <- list(spectra.tst, spectra.df)
  return(spect.out)
}
